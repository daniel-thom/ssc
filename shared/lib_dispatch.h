/**
BSD-3-Clause
Copyright 2019 Alliance for Sustainable Energy, LLC
Redistribution and use in source and binary forms, with or without modification, are permitted provided 
that the following conditions are met :
1.	Redistributions of source code must retain the above copyright notice, this list of conditions 
and the following disclaimer.
2.	Redistributions in binary form must reproduce the above copyright notice, this list of conditions 
and the following disclaimer in the documentation and/or other materials provided with the distribution.
3.	Neither the name of the copyright holder nor the names of its contributors may be used to endorse 
or promote products derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, 
INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
ARE DISCLAIMED.IN NO EVENT SHALL THE COPYRIGHT HOLDER, CONTRIBUTORS, UNITED STATES GOVERNMENT OR UNITED STATES 
DEPARTMENT OF ENERGY, NOR ANY OF THEIR EMPLOYEES, BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, 
OR CONSEQUENTIAL DAMAGES(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; 
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, 
WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT 
OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#ifndef __LIB_DISPATCH_H__
#define __LIB_DISPATCH_H__

#include <memory>


#include "lib_battery.h"
#include "lib_battery_model.h"
#include "lib_battery_controller.h"



// Forward declarations to speed up build
struct BatteryPower;
class BatteryPowerFlow;
class UtilityRate;
class UtilityRateCalculator;

struct dispatch_state
{
    /// Reset the time-step power quantities to 0
    void reset();

//    / Copy the enumeration for AC/DC connected systems from ChargeController
//    enum CONNECTION { DC_CONNECTED, AC_CONNECTED };

    double powerPV;				   ///< The power production of the PV array (kW)
    double powerLoad;			   ///< The power required by the electric load (kW)
    double powerGrid;              ///< The power flow to and from the grid (> 0, to grid, < 0 from grid) (kW)

    double powerBatteryDC; 	       ///< The power flow to and from the battery (> 0, discharging, < 0 charging) (kWdc)
    double powerBatteryAC; 	       ///< The power flow to and from the battery (> 0, discharging, < 0 charging) (kWac)
    double powerBatteryTarget;	   ///< A user specified or alogithm calculated target dispatch power (kW)

    double powerPVThroughSharedInverter; ///< The power going through the shared inverter (kW)
    double powerPVToLoad;          ///< The power from PV to the electric load (kW)
    double powerPVToBattery;       ///< The power from PV to the battery (kW)
    double powerPVToGrid;          ///< The power from PV to the grid (kW)
    double powerPVClipped;		   ///< The power from PV that will be clipped if not used in the battery (kW)

    double powerClippedToBattery;  ///< The power from that would otherwise have been clipped to the battery (kW)
    double powerGridToBattery;     ///< The power from the grid to the battery (kW)
    double powerGridToLoad;        ///< The power from the grid to the electric load (kW)
    double powerBatteryToLoad;     ///< The power from the battery to the electric load (kW)
    double powerBatteryToGrid;     ///< The power from the battery to the grid (kW)

    double powerFuelCell;          ///< The power from the fuelcell (kW)
    double powerFuelCellToGrid;    ///< The power from the fuelcell to the grid (kW)
    double powerFuelCellToLoad;    ///< The power from the fuelcell to the load (kW)
    double powerFuelCellToBattery; ///< The power from the fuelcell to the battery (kW)
    double powerGeneratedBySystem; /// The power generated by the combined power generator and battery (kW)

    double PVInverterEff;
    double powerPVInverterDraw;	   ///< The power draw from the PV inverter (kW)
    double powerSystemLoss;        ///< The parasitic power loss in the system (kW)
    double powerConversionLoss;    ///< The power loss due to conversions in the battery power electronics (kW)
    double voltageSystem;		   ///< The system voltage

//    std::sharedSharedInverter * sharedInverter;	 ///< The shared inverter between the PV and battery for a DC-connected system
};

/*
Dispatch Base Class - can envision many potential modifications. Goal is to define standard API
*/
class dispatch_interface
{
public:

    enum PV_PRIORITY { MEET_LOAD, CHARGE_BATTERY };
    dispatch_interface() = default;

    dispatch_interface(std::shared_ptr<battery> Battery,
               double dt,
               double SOC_min,
               double SOC_max,
               int current_choice,
               double Ic_max,
               double Id_max,
               double Pc_max_kwdc,
               double Pd_max_kwdc,
               double Pc_max_kwac,
               double Pd_max_kwac,
               double t_min,
               int dispatch_mode,
               int meter_position);

    virtual ~dispatch_interface();

    /// Public API to run the battery dispatch model for the current timestep, given the system power, and optionally the electric load and amount of system clipping
    virtual void dispatch(const storage_time_state &time) = 0;



    /// Method to recalculate the battery state based upon the final constrained current
    virtual void finalize(const storage_time_state &time, double &I);

    // ac outputs
    double power_tofrom_battery();
    double power_tofrom_grid();
    double power_gen();
    double power_pv_to_load();
    double power_battery_to_load();
    double power_grid_to_load();
    double power_fuelcell_to_load();
    double power_pv_to_batt();
    double power_grid_to_batt();
    double power_fuelcell_to_batt();
    double power_pv_to_grid();
    double power_battery_to_grid();
    double power_fuelcell_to_grid();
    double power_conversion_loss();
    double power_system_loss();

    virtual double power_grid_target(){	return 0;}
    virtual double power_batt_target(){ return 0.;}
    virtual double cost_to_cycle() { return 0.;}

    // control settings
    double battery_power_to_fill();

    message get_messages();

    /// Return a pointer to the underlying calculated power quantities
    BatteryPower * getBatteryPower();

    /// Return a pointer to the object which calculates the battery power flow
    BatteryPowerFlow * getBatteryPowerFlow();

protected:

    void check_constraints(dispatch_state& state, double& I, std::shared_ptr<charge_controller> controller, bool can_grid_charge ){
        auto params = controller->params;
        // Don't allow grid charging unless explicitly allowed (reduce charging)
        if (I < 0 && state.powerGridToBattery > tolerance && !can_grid_charge)
        {
            if (fabs(state.powerBatteryAC) < tolerance)
                I += (state.powerGridToBattery * util::kilowatt_to_watt / controller->get_V());
            else
                I += (state.powerGridToBattery / fabs(state.powerBatteryAC)) *fabs(I);
        }
            // Don't allow grid charging if producing PV
        else if (params->connection == battery_controller_params::DC_CONNECTED &&
                 state.powerGridToBattery &&
                 (state.powerPVToGrid > 0 || state.powerPVToLoad > 0))
        {
            if (fabs(state.powerBatteryAC) < tolerance)
                I += (state.powerGridToBattery * util::kilowatt_to_watt / battery_model->get_V());
            else
                I += (state.powerGridToBattery / fabs(state.powerBatteryAC)) *fabs(I);
        }
            // Don't allow battery to discharge if it gets wasted due to inverter efficiency limitations
            // Typically, this would be due to low power flow, so just cut off battery.
        else if (params->connection == battery_controller_params::DC_CONNECTED && state.PVInverterEff < params->inverter_efficiency_cutoff)
        {
            // The requested DC power
            double powerBatterykWdc = battery_model->get_I() * battery_model->get_V() * util::watt_to_kilowatt;

            // if battery discharging, see if can back off to get higher efficiency
            if (state.powerBatteryDC > 0) {
                if (powerBatterykWdc + state.powerPV > params->inverter_AC_nameplate_kW) {
                    powerBatterykWdc = params->inverter_AC_nameplate_kW - state.powerPV;
                    powerBatterykWdc = fmax(powerBatterykWdc, 0);
                }
                I = powerBatterykWdc * util::kilowatt_to_watt / battery_model->get_V();
            }
                // if charging, this will also be due to low powerflow from grid-charging, just cut off that component
            else if (state.powerBatteryDC < 0 && state.powerGridToBattery > 0){
                I *= fmax(1.0 - fabs(state.powerGridToBattery * params->inverter_AC_nameplate_kW * 0.01 / state.powerBatteryDC), 0);
            }
            else {
                iterate = false;
            }
        }

        // reset
        if (iterate)
        {
            battery_model->set_state(init);
            state.powerBatteryDC = 0;
            state.powerBatteryAC = 0;
            state.powerGridToBattery = 0;
            state.powerBatteryToGrid = 0;
            state.powerPVToGrid = 0;
        }
    }

//    // Initialization help
//    void init(battery *Battery,
//              double dt_hour,
//              int current_choice,
//              double t_min,
//              int mode);

};

/*
Manual dispatch class
*/
class dispatch_manual : public dispatch_interface
{
public:
    dispatch_manual(std::shared_ptr<battery> Battery,
                      double dt_hour,
                      double SOC_min,
                      double SOC_max,
                      int current_choice,
                      double Ic_max,
                      double Id_max,
                      double Pc_max_kwdc,
                      double Pd_max_kwdc,
                      double Pc_max_kwac,
                      double Pd_max_kwac,
                      double t_min,
                      int mode,
                      int meterPosition,
                      util::matrix_t<size_t> dm_dynamic_sched,
                      util::matrix_t<size_t> dm_dynamic_sched_weekend,
                      std::vector<bool> can_charge,
                      std::vector<bool> can_discharge,
                      std::vector<bool> can_gridcharge,
                      std::vector<bool> can_fuelcellcharge,
                      std::map<size_t, double> dm_percent_discharge,
                      std::map<size_t, double> dm_percent_gridcharge);

    // deep copy constructor (new memory), from dispatch to this
    dispatch_manual(const dispatch_interface& dispatch);

    // copy members from dispatch to this
    virtual void copy(const dispatch_interface * dispatch);

    virtual ~dispatch_manual(){};

    /// Public API to run the battery dispatch model for the current timestep, given the system power, and optionally the electric load, amount of system clipping, or specified battery power
    virtual void dispatch(const storage_time_state &time);

protected:

    /// Helper function to internally set up the dispatch model
    virtual void prepareDispatch(size_t hour_of_year, size_t step);

    // Initialization help
    void init(util::matrix_t<float> dm_dynamic_sched,
              util::matrix_t<float> dm_dynamic_sched_weekend,
              std::map<size_t, double> dm_percent_discharge,
              std::map<size_t, double> dm_percent_gridcharge);

    void init_with_vects(
            util::matrix_t<size_t> dm_dynamic_sched,
            util::matrix_t<size_t> dm_dynamic_sched_weekend,
            std::vector<bool>,
            std::vector<bool>,
            std::vector<bool>,
            std::vector<bool>,
            std::map<size_t, double> dm_percent_discharge,
            std::map<size_t, double> dm_percent_gridcharge);

    void SOC_controller();
    bool check_constraints(double &I, size_t count);

    util::matrix_t < size_t > _sched;
    util::matrix_t < size_t > _sched_weekend;

    std::vector<bool> _charge_array;
    std::vector<bool> _discharge_array;
    std::vector<bool> _gridcharge_array;
    std::vector<bool> _fuelcellcharge_array;

    double _percent_discharge;
    double _percent_charge;

    std::map<size_t, double>  _percent_discharge_array;
    std::map<size_t, double> _percent_charge_array;
};

class grid_point
{
    /**
    Class for behind-the-meter dispatch which encapsulates the required grid power, hour, and step:
    grid_point = [grid_power, hour, step]
    */
public:
    grid_point(double grid = 0., size_t hour = 0, size_t step = 0) :
            _grid(grid), _hour(hour), _step(step){}
    double Grid() const { return _grid; }
    size_t Hour() const { return _hour; }
    size_t Step() const { return _step; }

private:
    double _grid;
    size_t _hour;
    size_t _step;
};

struct byGrid
{
    bool operator()(grid_point const  &a, grid_point const &b)
    {
        return a.Grid() > b.Grid();
    }
};
typedef std::vector<grid_point> grid_vec;

/*! Automated dispatch base class */
class dispatch_automatic : public dispatch_interface
{
    /**
    Class contains methods and data common to all automated dispatch strategies in SAM.
    This includes:
        1. Dispatch method which discharges battery based on a power setpoint for each time step rather than energy amount used in manual mode
        2. Initialization of PV power forecast used for automation
    */
public:
    dispatch_automatic(
            std::shared_ptr<battery> Battery,
            double dt,
            double SOC_min,
            double SOC_max,
            int current_choice,
            double Ic_max,
            double Id_max,
            double Pc_max_kwdc,
            double Pd_max_kwdc,
            double Pc_max_kwac,
            double Pd_max_kwac,
            double t_min,
            int dispatch_mode,
            int pv_dispatch,
            size_t nyears,
            size_t look_ahead_hours,
            double dispatch_update_frequency_hours,
            bool can_charge,
            bool can_clipcharge,
            bool can_grid_charge,
            bool can_fuelcell_charge
    );

    virtual ~dispatch_automatic(){};

    // deep copy constructor (new memory), from dispatch to this
    dispatch_automatic(const dispatch_interface& dispatch);

    // copy members from dispatch to this
    virtual void copy(const dispatch_interface * dispatch);

    /// Public API to run the battery dispatch model for the current timestep, given the system power, and optionally the electric load, amount of system clipping, or specified battery power
    virtual void dispatch(const storage_time_state &time);

    /*! Compute the updated power to send to the battery over the next N hours */
    virtual void update_dispatch(size_t hour_of_year, size_t step, size_t idx)=0;

    /*! Pass in the PV power forecast */
    virtual void update_pv_data(std::vector<double> P_pv_dc);

    /*! Pass in the user-defined dispatch power vector */
    virtual void set_custom_dispatch(std::vector<double> P_batt_dc);

    /* Check constraints and re-dispatch if needed */
    virtual bool check_constraints(double &I, size_t count);

    /// Return the battery power target set by the controller
    double power_batt_target();

protected:

    /*! Initialize with a pointer*/
    void init_with_pointer(const dispatch_automatic * tmp);

    /*! Full time-series of PV production [kW] */
    double_vec _P_pv_dc;

    /*! The index of the current day (hour * steps_per_hour + step) */
    size_t _day_index;

    /*! The index of the current month (0-11) */
    size_t _month;

    /*! The number of steps in the look ahead, assumed to be 24 hours * steps_per_hour */
    size_t _num_steps;

    /*! Time series of length (24 hours * steps_per_hour) of battery powers [kW] */
    double_vec _P_battery_use;

    /*! The index of year the dispatch was last updated */
    size_t _hour_last_updated;

    /*! The index of year the dispatch was last updated */
    size_t _index_last_updated;

    /*! The amount of indices to wait before updating */
    size_t _d_index_update;

    /*! The timestep in hours (hourly = 1, half_hourly = 0.5, etc) */
    double _dt_hour;

    /*! The frequency to update the dispatch [hour] */
    double _dt_hour_update;

    /*! An internal factor to describe how conservative the peak shaving algorithm should be */
    double _safety_factor;

    /*! The hours to look ahead in the simulation [hour] */
    size_t _look_ahead_hours;
};

/*! Automated dispatch class for behind-the-meter connections */
class dispatch_automatic_behind_the_meter : public dispatch_automatic
{
    /**
    Class contains methods and data required to automate dispatch for a behind-the-meter battery targeting peak-shaving applications.
    This includes:
        1. Methods to set or compute the grid power target (desired grid power at every step over the next 24 hours)
        2. Methods to program the dispatch to acheive the target
        3. Method to update the electric load forecast
    */
public:
    dispatch_automatic_behind_the_meter(
            std::shared_ptr<battery> Battery,
            double dt,
            double SOC_min,
            double SOC_max,
            int current_choice,
            double Ic_max,
            double Id_max,
            double Pc_max_kwdc,
            double Pd_max_kwdc,
            double Pc_max_kwac,
            double Pd_max_kwac,
            double t_min,
            int dispatch_mode,
            int pv_dispatch,
            size_t nyears,
            size_t look_ahead_hours,
            double dispatch_update_frequency_hours,
            bool can_charge,
            bool can_clipcharge,
            bool can_grid_charge,
            bool can_fuelcell_charge
    );

    virtual ~dispatch_automatic_behind_the_meter(){};

    // deep copy constructor (new memory), from dispatch to this
    dispatch_automatic_behind_the_meter(const dispatch_interface& dispatch);

    // copy members from dispatch to this
    virtual void copy(const dispatch_interface * dispatch);

    /// Public API to run the battery dispatch model for the current timestep, given the system power, and optionally the electric load, amount of system clipping, or specified battery power
    virtual void dispatch(const storage_time_state &time);

    /*! Compute the updated power to send to the battery over the next N hours */
    void update_dispatch(size_t hour_of_year, size_t step, size_t idx);

    /*! Pass in the load forecast */
    void update_load_data(std::vector<double> P_load_dc);

    /*! Pass in the grid power target vector */
    void set_target_power(std::vector<double> P_target);

    /*! Grid target power */
    double power_grid_target();

    enum BTM_TARGET_MODES {TARGET_SINGLE_MONTHLY, TARGET_TIME_SERIES};

protected:

    /*! Initialize with a pointer*/
    void init_with_pointer(const dispatch_automatic_behind_the_meter * tmp);

    void initialize(size_t hour_of_year);
    void check_debug(FILE *&p, bool & debug, size_t hour_of_year, size_t idx);
    void sort_grid(FILE *p, bool debug, size_t idx);
    void compute_energy(FILE *p, bool debug, double & E_max);
    void target_power(FILE*p, bool debug, double E_max, size_t idx);
    void set_battery_power(FILE *p, bool debug);
    void check_new_month(size_t hour_of_year, size_t step);


    std::shared_ptr<battery> _Battery;
    battery_state _Battery_initial;

    // allocated and managed internally
    dispatch_state state;

    // managed by BatteryPowerFlow
    std::unique_ptr<BatteryPower> m_batteryPower;

    // Charge & current limits controllers
    double _t_min;
    double _e_max;
    double _P_target;

    // rapid charge change controller
    int _t_at_mode; // [minutes]
    bool _charging;
    bool _prev_charging;
    bool _grid_recharge;

    // messages
    message _message;

    /*! Full time-series of loads [kW] */
    double_vec _P_load_dc;

    /*! Full time-series of target power [kW] */
    double_vec _P_target_input;

    /*! Time series of length (24 hours * steps_per_hour) of target powers [kW] */
    double_vec _P_target_use;

    /*! The target grid power for the month [kW] */
    double _P_target_month;

    /*! The grid power target at the current time [kW] */
    double _P_target_current;

    /* Vector of length (24 hours * steps_per_hour) containing grid calculation [P_grid, hour, step] */
    grid_vec grid;

    /* Vector of length (24 hours * steps_per_hour) containing sorted grid calculation [P_grid, hour, step] */
    grid_vec sorted_grid;
};

/*! Automated Front of Meter DC-connected battery dispatch */
class dispatch_automatic_front_of_meter : public dispatch_interface
{
public:
    /**
     Class takes forecast information about the PV production and Load Profile, plus PPA sell rate and electricity buy-rate signals
     and programs battery to strategically dispatch to maximize economic benefit by:
     1. Discharging during times of high PPA sell rates
     2. Charging from the grid during times of low electricity buy-rates (if grid charging allowed)
     3. Charging from the PV array during times of low PPA sell rates
     4. Charging from the PV array during times where the PV power would be clipped due to inverter limits (if DC-connected)
    */
    dispatch_automatic_front_of_meter(
            shared_ptr<battery> Battery, std::shared_ptr<const dispatch_FTM_prices>& params
    );

    virtual ~dispatch_automatic_front_of_meter();

    /*! deep copy constructor (new memory), from dispatch to this */
    dispatch_automatic_front_of_meter(const dispatch_automatic_front_of_meter& dispatch);

    /*! shallow copy from dispatch to this */
    virtual void copy(const dispatch_interface* dispatch);

    /// Public API to run the battery dispatch model for the current timestep, given the system power, and optionally the electric load, amount of system clipping, or specified battery power
    virtual void dispatch(const storage_time_state &time);

    /// Compute the updated power to send to the battery over the next N hours
    void update_dispatch(size_t hour_of_year, size_t step, size_t lifetimeIndex);

    /// Update cliploss data [kW]
    void update_cliploss_data(double_vec P_cliploss);

    /// Pass in the PV power forecast [kW]
    virtual void update_pv_data(std::vector<double> P_pv_dc);

    /*! Calculate the cost to cycle */
    void costToCycle();

    /*! Return the calculated cost to cycle ($/cycle)*/
    double cost_to_cycle() { return m_cycleCost; }

    /// Return benefit calculations
    double benefit_charge(){ return revenueToPVCharge; }
    double benefit_gridcharge() { return revenueToGridCharge; }
    double benefit_clipcharge() { return revenueToClipCharge; }
    double benefit_discharge() { return revenueToDischarge; }


protected:


    std::shared_ptr<battery> battery_model;
    battery_state battery_initial_state;

    std::shared_ptr<const dispatch_FTM_prices> params;

    std::unique_ptr<BatteryPowerFlow> power_flow;

    static double safety_factor = 0.003;
    const size_t look_ahead_steps;
    const size_t dt_index_update;

    dispatch_state state;
    size_t last_index_update;
    double cost_of_next_cycle;


    double _e_max;
    double _P_target;

    void setup_cost_forecast_vector();


    /*! Utility rate information */
    std::shared_ptr<UtilityRateCalculator> m_utilityRateCalculator;

    /* Computed benefits to charge, discharge, gridcharge, clipcharge */
    double revenueToPVCharge;
    double revenueToGridCharge;
    double revenueToClipCharge;
    double revenueToDischarge;

private:
    friend class dispatch_resiliency;
};
//
///*! Dispatches the battery in the case where the grid is unavailable */
//class dispatch_resiliency : public dispatch_interface {
//public:
//
//    explicit dispatch_resiliency(dispatch_automatic_behind_the_meter* orig);
//
//    explicit dispatch_resiliency(dispatch_manual_t* orig);
//
//protected:
//    double_vec battery_use;
//
//    double_vec load;
//
//    double_vec pv_gen;
//
//    void init_powerflow();
//
//    void set_pv_gen(double_vec pv);
//
//    void dispatch(size_t year, size_t hour_of_year, size_t step) override;
//
//};


#endif
